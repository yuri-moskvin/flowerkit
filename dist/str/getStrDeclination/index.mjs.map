{"version":3,"file":"index.mjs","sources":[""],"sourcesContent":["/**\r\n * Returns the correct word form (declension) depending on the number.\r\n * Commonly used for Cyrillic languages (one, few, many).\r\n *\r\n * @param {number} num Source number (can be negative)\r\n * @param {[string,string,string]} words Exactly three declensions: [one, few, many]\r\n * @returns {string} Selected declension\r\n * @throws {TypeError} If arguments are invalid\r\n * @example\r\n * const words: [ string, string, string ] = [ \"товар\", \"товара\", \"товаров\" ];\r\n * getStrDeclination(1, words); // \"товар\"\r\n * getStrDeclination(2, words); // \"товара\"\r\n * getStrDeclination(5, words); // \"товаров\"\r\n */\r\nexport const getStrDeclination = (num: number, words: readonly [string, string, string]): string => {\r\n  if (!Number.isFinite(num)) {\r\n    throw new TypeError(\"getStrDeclination: num must be a finite number\");\r\n  }\r\n  if (!Array.isArray(words) || words.length !== 3 || words.some((w) => typeof w !== \"string\")) {\r\n    throw new TypeError(\"getStrDeclination: words must be a tuple of three strings [one, few, many]\");\r\n  }\r\n\r\n  const n = Math.abs(num);\r\n  const mod100 = n % 100;\r\n  if (mod100 > 4 && mod100 < 20) {\r\n    return words[2];\r\n  }\r\n\r\n  const mod10 = n % 10;\r\n  const index = (mod10 < 5) ? [ 2, 0, 1, 1, 1 ][mod10] : 2;\r\n  return words[index];\r\n};\r\n"],"names":["getStrDeclination","num","words","Number","isFinite","TypeError","Array","isArray","length","some","w","n","Math","abs","mod100","mod10","index"],"mappings":";;;;;;;;;;;;;;MAcaA,kBAAoBA,CAACC,IAAaC,SAC7C,IAAKC,OAAOC,SAASH,KACnB,MAAM,IAAII,UAAU,kDAEtB,IAAKC,MAAMC,QAAQL,QAAUA,MAAMM,SAAW,GAAKN,MAAMO,MAAMC,UAAaA,IAAM,WAChF,MAAM,IAAIL,UAAU,8EAGtB,MAAMM,EAAIC,KAAKC,IAAIZ,KACnB,MAAMa,OAASH,EAAI,IACnB,GAAIG,OAAS,GAAKA,OAAS,GACzB,OAAOZ,MAAM,GAGf,MAAMa,MAAQJ,EAAI,GAClB,MAAMK,MAASD,MAAQ,EAAK,CAAE,EAAG,EAAG,EAAG,EAAG,GAAIA,OAAS,EACvD,OAAOb,MAAMc,MAAM"}