{"version":3,"file":"index.mjs","sources":[""],"sourcesContent":["import { getDocument } from \"ssr-window\";\r\n\r\ntype TGetExternalScriptProps = {\r\n  isAsync?: boolean;\r\n  isDefer?: boolean;\r\n  src: string;\r\n  appendTo?: Node | HTMLElement;\r\n  id?: string;\r\n  crossorigin?: string;\r\n  type?: string;\r\n};\r\n\r\n/**\r\n * Appends an external script to the page and resolves when it's loaded.\r\n *\r\n * @param {TGetExternalScriptProps} props Options\r\n * @param {boolean} [props.isAsync=true] `async` attribute\r\n * @param {boolean} [props.isDefer=false] `defer` attribute\r\n * @param {string} props.src Script source URL\r\n * @param {Node|HTMLElement} [props.appendTo=document.body] Element to append the script to\r\n * @param {string} [props.id] Script element id\r\n * @param {string} [props.crossorigin] `crossorigin` attribute\r\n * @param {string} [props.type] `type` attribute\r\n * @returns {Promise<HTMLScriptElement>} Promise that resolves to the created script element\r\n * @example\r\n * getExternalScript({ src: \"https://cdn.example.com/lib.js\", id: \"lib\" })\r\n *   .then(() => console.log(\"Loaded\"));\r\n */\r\nexport const getExternalScript = (props: TGetExternalScriptProps): Promise<HTMLScriptElement> => {\r\n  const {\r\n    isAsync = true,\r\n    isDefer = false,\r\n    src,\r\n    type,\r\n    appendTo = getDocument().body,\r\n    id,\r\n    crossorigin,\r\n  } = props ?? ({} as TGetExternalScriptProps);\r\n\r\n  if (typeof src !== \"string\" || !src) {\r\n    return Promise.reject(new TypeError(\"getExternalScript: props.src must be a non-empty string\"));\r\n  }\r\n  if (!!crossorigin && typeof crossorigin !== \"string\") {\r\n    return Promise.reject(new TypeError(\"getExternalScript: props.crossorigin must be a string if provided\"));\r\n  }\r\n  if (!appendTo || typeof (appendTo as any).appendChild !== \"function\") {\r\n    return Promise.reject(new TypeError(\"getExternalScript: props.appendTo must be a Node/HTMLElement if provided\"));\r\n  }\r\n\r\n  return new Promise<HTMLScriptElement>((resolve, reject) => {\r\n    let isReady = false;\r\n    const script = getDocument().createElement(\"script\");\r\n    script.src = src;\r\n    script.async = isAsync;\r\n    script.defer = isDefer;\r\n\r\n    if (id) {\r\n      script.id = id;\r\n    }\r\n    if (crossorigin) {\r\n      (script as any).crossorigin = crossorigin;\r\n    }\r\n    if (type) {\r\n      script.type = type;\r\n    }\r\n\r\n    script.onerror = (err: Event | string) => {\r\n      reject(err);\r\n      script.onerror = null;\r\n    };\r\n    script.onload = script.onreadystatechange = function (this: any): void {\r\n      if (!isReady && (!this.readyState || this.readyState === \"complete\")) {\r\n        isReady = true;\r\n        resolve(script);\r\n        script.onload = null;\r\n        script.onerror = null;\r\n      }\r\n    };\r\n\r\n    appendTo.appendChild(script);\r\n  });\r\n};\r\n"],"names":["getExternalScript","props","isAsync","isDefer","src","type","appendTo","getDocument","body","id","crossorigin","Promise","reject","TypeError","appendChild","resolve","isReady","script","createElement","async","defer","onerror","err","onload","onreadystatechange","this","readyState"],"mappings":";;;;;;;;;;;;;;;;GA4BO,MAAMA,kBAAqBC,QAChC,MAAMC,QACJA,QAAU,KAAIC,QACdA,QAAU,MAAKC,IACfA,IAAGC,KACHA,KAAIC,SACJA,SAAWC,cAAcC,KAAIC,GAC7BA,GAAEC,YACFA,aACET,OAAU,CAAA,EAEd,UAAWG,MAAQ,WAAaA,IAC9B,OAAOO,QAAQC,OAAO,IAAIC,UAAU,4DAEtC,KAAMH,oBAAsBA,cAAgB,SAC1C,OAAOC,QAAQC,OAAO,IAAIC,UAAU,sEAEtC,IAAKP,iBAAoBA,SAAiBQ,cAAgB,WACxD,OAAOH,QAAQC,OAAO,IAAIC,UAAU,6EAGtC,OAAO,IAAIF,SAA2B,CAACI,QAASH,UAC9C,IAAII,QAAU,MACd,MAAMC,OAASV,cAAcW,cAAc,UAC3CD,OAAOb,IAAMA,IACba,OAAOE,MAAQjB,QACfe,OAAOG,MAAQjB,QAEf,GAAIM,GACFQ,OAAOR,GAAKA,GAEd,GAAIC,YACDO,OAAeP,YAAcA,YAEhC,GAAIL,KACFY,OAAOZ,KAAOA,KAGhBY,OAAOI,QAAWC,MAChBV,OAAOU,KACPL,OAAOI,QAAU,IAAI,EAEvBJ,OAAOM,OAASN,OAAOO,mBAAqB,WAC1C,IAAKR,WAAaS,KAAKC,YAAcD,KAAKC,aAAe,YAAa,CACpEV,QAAU,KACVD,QAAQE,QACRA,OAAOM,OAAS,KAChBN,OAAOI,QAAU,IACnB,CACF,EAEAf,SAASQ,YAAYG,OAAO,GAC5B"}