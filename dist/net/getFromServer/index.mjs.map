{"version":3,"file":"index.mjs","sources":[""],"sourcesContent":["\r\nimport { getDocument, getWindow } from \"ssr-window\";\r\nimport { bubble } from \"../../evt/bubble/index.ts\";\r\nimport { getObjFromFormData } from \"../../obj/getObjFromFormData/index.ts\";\r\nimport { getFormDataFromObj } from \"../getFormDataFromObj/index.ts\";\r\nimport { getUrlWithQueryParams } from \"../getUrlWithQueryParams/index.ts\";\r\n\r\ntype THttpMethod = \"GET\" | \"PUT\" | \"POST\" | \"DELETE\" | \"HEAD\" | \"CONNECT\" | \"OPTIONS\" | \"TRACE\";\r\ntype TContentType = \"auto\" | \"application/json\" | \"application/x-www-form-urlencoded\" | \"multipart/form-data\";\r\ntype TResponseType = \"text\" | \"json\" | \"blob\" | \"arrayBuffer\";\r\n\r\ntype TPlainObject = Record<string, unknown>;\r\ntype TRequestData = TPlainObject | FormData | null;\r\n\r\ntype TGetRespFn = (resp: Response) => Promise<unknown>;\r\ntype TGetSuccessRespFn<T> = (data: T) => T;\r\n\r\ntype TFetchExtra = Omit<RequestInit, \"method\" | \"headers\" | \"body\" | \"signal\" | \"mode\" | \"credentials\" | \"redirect\" | \"cache\" | \"referrerPolicy\">;\r\n\r\ntype TGetFromServerProps<T> = {\r\n  contentType?: TContentType;\r\n  isBubble?: boolean;\r\n  timeout?: number;\r\n  method?: THttpMethod;\r\n  mode?: RequestMode;\r\n  signal?: AbortSignal | null;\r\n  data?: TRequestData;\r\n  getSuccessResp?: TGetSuccessRespFn<T>;\r\n  getResp?: TGetRespFn;\r\n  type?: TResponseType;\r\n  url?: string;\r\n  headers?: Record<string, string>;\r\n  allowedCodes?: number[];\r\n  credentials?: RequestCredentials;\r\n  redirect?: RequestRedirect;\r\n  cache?: RequestCache;\r\n  referrerPolicy?: ReferrerPolicy;\r\n  fetchProps?: TFetchExtra;\r\n};\r\n\r\n/**\r\n * Performs an HTTP request (`fetch`) with handy defaults, content-type handling,\r\n * query param building, and optional bubbling of a \"getFromServer\" event.\r\n *\r\n * @template T\r\n * @param {TGetFromServerProps<T>} [props={}] Request parameters\r\n * @returns {Promise<T>} Promise with parsed response (type depends on `type` option)\r\n * @throws {TypeError} getFromServer: url must be a string\r\n * @throws {TypeError} getFromServer: allowedCodes must be an array of integers\r\n * @throws {TypeError} getFromServer: data must be a plain object, FormData, or null\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\r\n * @example\r\n * const user = await getFromServer<{ userId: number }>({ url: \"/api/user?id=1\", method: \"GET\" });\r\n */\r\nexport const getFromServer = async <T = unknown>(props: TGetFromServerProps<T> = {}): Promise<T> => {\r\n  const {\r\n    contentType = \"auto\",\r\n    isBubble = true,\r\n    timeout = 15000,\r\n    method = \"GET\",\r\n    mode = \"cors\",\r\n    signal = null,\r\n    data = null,\r\n    getSuccessResp = ((resp: T) => resp) as TGetSuccessRespFn<T>,\r\n    getResp,\r\n    type = \"json\",\r\n    url = getWindow().location.href || \"./\",\r\n    headers = {},\r\n    allowedCodes = [],\r\n    credentials = \"same-origin\",\r\n    redirect = \"follow\",\r\n    referrerPolicy = \"no-referrer-when-downgrade\",\r\n    cache = \"default\",\r\n    fetchProps = {},\r\n  } = props;\r\n\r\n\r\n  if (typeof url !== \"string\") {\r\n    throw new TypeError(\"getFromServer: url must be a string\");\r\n  }\r\n\r\n  if (!Array.isArray(allowedCodes) || !allowedCodes.every((c) => Number.isInteger(c))) {\r\n    throw new TypeError(\"getFromServer: allowedCodes must be an array of integers\");\r\n  }\r\n\r\n  if (data !== null && typeof data !== \"object\") {\r\n    throw new TypeError(\"getFromServer: data must be a plain object, FormData, or null\");\r\n  }\r\n\r\n  let timer: ReturnType<typeof setTimeout> | null = null;\r\n  const queries: Array<Promise<any>> = [];\r\n\r\n  const isPost = method.toUpperCase() === \"POST\";\r\n  const isFormData = (v: unknown): v is FormData => typeof FormData !== \"undefined\" && v instanceof FormData;\r\n\r\n  /**\r\n   * Produces request body based on contentType and data\r\n   * @private\r\n   * @returns {null | FormData | string}\r\n   */\r\n  const getBody = (): FormData | string | null => {\r\n    switch (true) {\r\n      case contentType === \"application/json\" && isPost:\r\n        return JSON.stringify(isFormData(data) ? getObjFromFormData(data) : (data || {}));\r\n      case [ \"application/x-www-form-urlencoded\", \"multipart/form-data\", \"auto\" ].includes(contentType) && isPost:\r\n        return isFormData(data)\r\n          ? data\r\n          : getFormDataFromObj((data || {}) as Record<string, unknown>);\r\n      default:\r\n        return null;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Reject helper\r\n   * @private\r\n   */\r\n  const getReject = <E = unknown>(reason: E): Promise<never> => Promise.reject(reason);\r\n\r\n  /**\r\n   * Timeout helper\r\n   * @private\r\n   */\r\n  const setTimer = (cb: (code: number) => void): ReturnType<typeof setTimeout> => {\r\n    timer = setTimeout(() => cb(408), timeout);\r\n    return timer;\r\n  };\r\n\r\n  /**\r\n   * URL builder (adds query params for GET-like methods)\r\n   * @private\r\n   */\r\n  const getUrl = (): string => {\r\n    const methodsNoBody: THttpMethod[] = [ \"GET\", \"HEAD\", \"CONNECT\", \"OPTIONS\", \"TRACE\" ];\r\n    return (methodsNoBody.includes(method) && data !== null)\r\n      ? getUrlWithQueryParams(\r\n        url, isFormData(data)\r\n          ? data\r\n          : (data as Record<string, string | number | boolean | null>)\r\n      )\r\n      : url;\r\n  };\r\n\r\n  /**\r\n   * Response parser\r\n   * @private\r\n   */\r\n  const getResponse = async (resp: Response): Promise<T> => {\r\n    if (timer) {\r\n      clearTimeout(timer);\r\n    }\r\n    if (typeof getResp === \"function\") {\r\n      return await getResp(resp) as T;\r\n    }\r\n    const { ok, status } = resp;\r\n    if (ok || (allowedCodes.length > 0 && allowedCodes.includes(status))) {\r\n      switch (type) {\r\n        case \"arrayBuffer\": return await resp.arrayBuffer() as unknown as T;\r\n        case \"json\": return await resp.json() as T;\r\n        case \"blob\": return await resp.blob() as unknown as T;\r\n        default: return await resp.text() as unknown as T;\r\n      }\r\n    }\r\n    return await getReject(resp);\r\n  };\r\n\r\n  /**\r\n   * Headers builder\r\n   * @private\r\n   */\r\n  const getHeaders = (): Record<string, string> => {\r\n    const result: Record<string, string> = { ...(headers || {}) };\r\n    if (contentType !== \"auto\") {\r\n      result[\"Content-Type\"] = contentType;\r\n    }\r\n    return result;\r\n  };\r\n\r\n  const fetchParams: RequestInit = {\r\n    method,\r\n    body: getBody() as BodyInit | null,\r\n    mode,\r\n    signal: (signal ?? undefined) as AbortSignal | undefined,\r\n    credentials,\r\n    redirect,\r\n    cache,\r\n    referrerPolicy,\r\n    headers: getHeaders(),\r\n    ...fetchProps,\r\n  };\r\n\r\n  queries.push(fetch(getUrl(), fetchParams));\r\n\r\n  if (timeout && timeout !== Infinity) {\r\n    queries.push(new Promise<never>((_resolve, reject) => setTimer(reject as (code: number) => void)));\r\n  }\r\n\r\n  return await Promise.race(queries).then(\r\n    (resp: Response) =>\r\n      getResponse(resp).then((parsed) => {\r\n        if (isBubble && typeof window !== \"undefined\") {\r\n          bubble(getDocument(), getFromServer.name, parsed);\r\n        }\r\n        return getSuccessResp(parsed);\r\n      }), (reject) => getReject(reject)\r\n  );\r\n};\r\n"],"names":["getFromServer","async","props","contentType","isBubble","timeout","method","mode","signal","data","getSuccessResp","resp","getResp","type","url","getWindow","location","href","headers","allowedCodes","credentials","redirect","referrerPolicy","cache","fetchProps","TypeError","Array","isArray","every","c","Number","isInteger","timer","queries","isPost","toUpperCase","isFormData","v","FormData","getBody","JSON","stringify","getObjFromFormData","includes","getFormDataFromObj","getReject","reason","Promise","reject","setTimer","cb","setTimeout","getUrl","methodsNoBody","getUrlWithQueryParams","getResponse","clearTimeout","ok","status","length","arrayBuffer","json","blob","text","getHeaders","result","fetchParams","body","undefined","push","fetch","Infinity","_resolve","race","then","parsed","window","bubble","getDocument","name"],"mappings":"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"}