{"version":3,"file":"index.cjs","sources":[""],"sourcesContent":["type TRuleType = \"string\" | \"number\" | \"boolean\" | \"object\" | \"array\";\r\ntype TRulesSchema<TInput extends Record<string, unknown>, TOutput extends Record<string, unknown>> = {\r\n  [K in keyof TInput]?: {\r\n    output?: keyof TOutput | string;\r\n    type?: TRuleType;\r\n    fallback?: unknown;\r\n    getValue?: (value: TInput[K], fallback: unknown) => unknown;\r\n  };\r\n};\r\n\r\nconst validateRulesSchema = <TInput extends Record<string, unknown>, TOutput extends Record<string, unknown>>(\r\n  rules: TRulesSchema<TInput, TOutput>\r\n): void => {\r\n  if (!rules || typeof rules !== \"object\" || Array.isArray(rules)) {\r\n    throw new TypeError(\"getObjWithFallbacks: rules must be a plain object\");\r\n  }\r\n\r\n  Object.entries(rules).forEach(([ key, rule ]) => {\r\n    if (rule === null || typeof rule !== \"object\" || Array.isArray(rule)) {\r\n      throw new TypeError(`getObjWithFallbacks: rules.${key} must be a rule object`);\r\n    }\r\n\r\n    if (rule.output !== undefined && typeof rule.output !== \"string\") {\r\n      throw new TypeError(`getObjWithFallbacks: rules.${key}.output must be a string`);\r\n    }\r\n\r\n    if (rule.type !== undefined) {\r\n      const validTypes: TRuleType[] = [ \"string\", \"number\", \"boolean\", \"object\", \"array\" ];\r\n      if (!validTypes.includes(rule.type)) {\r\n        throw new TypeError(\r\n          `getObjWithFallbacks: rules.${key}.type must be one of: ${validTypes.join(\", \")}`\r\n        );\r\n      }\r\n    }\r\n\r\n    if (rule.getValue !== undefined && typeof rule.getValue !== \"function\") {\r\n      throw new TypeError(`getObjWithFallbacks: rules.${key}.getValue must be a function`);\r\n    }\r\n\r\n    const validProperties = [ \"output\", \"type\", \"fallback\", \"getValue\" ];\r\n    const hasValidProperties = validProperties.some((prop) => prop in rule);\r\n    if (!hasValidProperties) {\r\n      throw new TypeError(\r\n        `getObjWithFallbacks: rules.${key} must have at least one of: ${validProperties.join(\", \")}`\r\n      );\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Gets an object with fixed keys and values\r\n * @template TInput,TOutput\r\n * @param {TInput} data Source data\r\n * @param {TRulesSchema<TInput,TOutput>} [rules={}] Rules for transformation\r\n * @param {Partial<Record<TRuleType, unknown>>} [fallbacks={}] Fallback for each type of values\r\n * @returns {TOutput & Partial<TInput>} Transformed object\r\n * @throws {TypeError} getObjWithFallbacks: data must be a plain object\r\n * @throws {TypeError} getObjWithFallbacks: rules must be a plain object\r\n * @throws {TypeError} getObjWithFallbacks: rules validation failed\r\n * @example\r\n */\r\nexport const getObjWithFallbacks = <\r\n  TInput extends Record<string, unknown>,\r\n  TOutput extends Record<string, unknown> = Record<string, unknown>\r\n>(\r\n  data: TInput,\r\n  rules: TRulesSchema<TInput, TOutput> = {},\r\n  fallbacks: Partial<Record<TRuleType, unknown>> = {}\r\n): TOutput & Partial<TInput> => {\r\n\r\n  if (!data || typeof data !== \"object\" || Array.isArray(data)) {\r\n    throw new TypeError(\"getObjWithFallbacks: data must be a plain object\");\r\n  }\r\n  if (!rules || typeof rules !== \"object\" || Array.isArray(rules)) {\r\n    throw new TypeError(\"getObjWithFallbacks: rules must be a plain object\");\r\n  }\r\n\r\n  validateRulesSchema(rules);\r\n\r\n  const placeholders: Record<TRuleType, unknown> = {\r\n    string: \"\",\r\n    number: 0,\r\n    boolean: false,\r\n    object: {},\r\n    array: [],\r\n    ...fallbacks,\r\n  } as const;\r\n\r\n  const newItem: Record<string, unknown> = {};\r\n\r\n  Object.entries(data).forEach(([ key, value ]) => {\r\n    const rule = (rules as Record<string, TRulesSchema<TInput, TOutput>[string]>)[key];\r\n\r\n    if (rule) {\r\n      const {\r\n        getValue,\r\n        fallback,\r\n        output = key?.toString() ?? \"\",\r\n        type = (Array.isArray(value) ? \"array\" : (value === null ? \"object\" : typeof value)) as TRuleType,\r\n      } = rule;\r\n\r\n      const getFallback = (t: TRuleType) => (typeof fallback === \"undefined\" ? placeholders[t] : fallback);\r\n\r\n      const getActualValue = (cfg: { type: TRuleType; value: unknown; isValid: (v: any) => boolean; }) => {\r\n        if (cfg.type === \"array\") {\r\n          return cfg.isValid(cfg.value) ? cfg.value : getFallback(\"array\");\r\n        }\r\n        if (cfg.type === \"object\") {\r\n          return cfg.isValid(cfg.value) ? cfg.value : getFallback(\"object\");\r\n        }\r\n        if (typeof cfg.value === cfg.type) {\r\n          return cfg.isValid(cfg.value) ? cfg.value : getFallback(cfg.type);\r\n        }\r\n        return getFallback(cfg.type);\r\n      };\r\n\r\n      if (output) {\r\n        if (typeof getValue === \"function\") {\r\n          newItem[output as string] = getValue(value as any, getFallback(Array.isArray(value) ? \"array\" : \"object\"));\r\n        } else {\r\n          switch (type) {\r\n            case \"string\":\r\n              newItem[output as string] = getActualValue({\r\n                type,\r\n                value: value?.toString() ?? getFallback(type),\r\n                isValid: (v) => typeof v === \"string\" && v.trim().length > 0,\r\n              });\r\n              break;\r\n            case \"number\": {\r\n              const num = Number(value);\r\n              newItem[output as string] = getActualValue({\r\n                type,\r\n                value: (Number.isNaN(num) || (typeof value !== \"number\" && num === 0)) ? getFallback(type) : num,\r\n                isValid: (v) => typeof v === \"number\" && Number.isFinite(v),\r\n              });\r\n              break;\r\n            }\r\n            case \"boolean\":\r\n              newItem[output as string] = getActualValue({\r\n                type,\r\n                value: Boolean(value),\r\n                isValid: (v) => typeof v === \"boolean\",\r\n              });\r\n              break;\r\n            case \"array\":\r\n              newItem[output as string] = getActualValue({\r\n                type: \"array\",\r\n                value,\r\n                isValid: (v) => Array.isArray(v),\r\n              });\r\n              break;\r\n            case \"object\":\r\n              newItem[output as string] = getActualValue({\r\n                type: Array.isArray(value) ? \"array\" as const : \"object\",\r\n                value,\r\n                isValid: (v) => v !== null && typeof v === \"object\" && !Array.isArray(v),\r\n              });\r\n              break;\r\n            default:\r\n              newItem[output as string] = value;\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      newItem[key] = value;\r\n    }\r\n  });\r\n\r\n  return newItem as TOutput & Partial<TInput>;\r\n};\r\n"],"names":["validateRulesSchema","rules","Array","isArray","TypeError","Object","entries","forEach","key","rule","output","undefined","type","validTypes","includes","join","getValue","validProperties","hasValidProperties","some","prop","getObjWithFallbacks","data","fallbacks","placeholders","string","number","boolean","object","array","newItem","value","fallback","toString","getFallback","t","getActualValue","cfg","isValid","v","trim","length","num","Number","isNaN","isFinite","Boolean"],"mappings":"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"}