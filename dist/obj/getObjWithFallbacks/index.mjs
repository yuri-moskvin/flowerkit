const validateRulesSchema=rules=>{if(!rules||typeof rules!=="object"||Array.isArray(rules))throw new TypeError("getObjWithFallbacks: rules must be a plain object");Object.entries(rules).forEach((([key,rule])=>{if(rule===null||typeof rule!=="object"||Array.isArray(rule))throw new TypeError(`getObjWithFallbacks: rules.${key} must be a rule object`);if(rule.output!==void 0&&typeof rule.output!=="string")throw new TypeError(`getObjWithFallbacks: rules.${key}.output must be a string`);if(rule.type!==void 0){const validTypes=["string","number","boolean","object","array"];if(!validTypes.includes(rule.type))throw new TypeError(`getObjWithFallbacks: rules.${key}.type must be one of: ${validTypes.join(", ")}`)}if(rule.getValue!==void 0&&typeof rule.getValue!=="function")throw new TypeError(`getObjWithFallbacks: rules.${key}.getValue must be a function`);const validProperties=["output","type","fallback","getValue"];const hasValidProperties=validProperties.some((prop=>prop in rule));if(!hasValidProperties)throw new TypeError(`getObjWithFallbacks: rules.${key} must have at least one of: ${validProperties.join(", ")}`)}))};
/**
 * Gets an object with fixed keys and values
 * @template TInput,TOutput
 * @param {TInput} data Source data
 * @param {TRulesSchema<TInput,TOutput>} [rules={}] Rules for transformation
 * @param {Partial<Record<TRuleType, unknown>>} [fallbacks={}] Fallback for each type of values
 * @returns {TOutput & Partial<TInput>} Transformed object
 * @throws {TypeError} getObjWithFallbacks: data must be a plain object
 * @throws {TypeError} getObjWithFallbacks: rules must be a plain object
 * @throws {TypeError} getObjWithFallbacks: rules validation failed
 * @example
 */const getObjWithFallbacks=(data,rules={},fallbacks={})=>{if(!data||typeof data!=="object"||Array.isArray(data))throw new TypeError("getObjWithFallbacks: data must be a plain object");if(!rules||typeof rules!=="object"||Array.isArray(rules))throw new TypeError("getObjWithFallbacks: rules must be a plain object");validateRulesSchema(rules);const placeholders={string:"",number:0,boolean:false,object:{},array:[],...fallbacks};const newItem={};Object.entries(data).forEach((([key,value])=>{const rule=rules[key];if(rule){const{getValue:getValue,fallback:fallback,output:output=key?.toString()??"",type:type=(Array.isArray(value)?"array":value===null?"object":typeof value)}=rule;const getFallback=t=>typeof fallback==="undefined"?placeholders[t]:fallback;const getActualValue=cfg=>{if(cfg.type==="array")return cfg.isValid(cfg.value)?cfg.value:getFallback("array");if(cfg.type==="object")return cfg.isValid(cfg.value)?cfg.value:getFallback("object");if(typeof cfg.value===cfg.type)return cfg.isValid(cfg.value)?cfg.value:getFallback(cfg.type);return getFallback(cfg.type)};if(output)if(typeof getValue==="function")newItem[output]=getValue(value,getFallback(Array.isArray(value)?"array":"object"));else switch(type){case"string":newItem[output]=getActualValue({type:type,value:value?.toString()??getFallback(type),isValid:v=>typeof v==="string"&&v.trim().length>0});break;case"number":{const num=Number(value);newItem[output]=getActualValue({type:type,value:Number.isNaN(num)||typeof value!=="number"&&num===0?getFallback(type):num,isValid:v=>typeof v==="number"&&Number.isFinite(v)});break}case"boolean":newItem[output]=getActualValue({type:type,value:Boolean(value),isValid:v=>typeof v==="boolean"});break;case"array":newItem[output]=getActualValue({type:"array",value:value,isValid:v=>Array.isArray(v)});break;case"object":newItem[output]=getActualValue({type:Array.isArray(value)?"array":"object",value:value,isValid:v=>v!==null&&typeof v==="object"&&!Array.isArray(v)});break;default:newItem[output]=value}}else newItem[key]=value}));return newItem};export{getObjWithFallbacks};
//# sourceMappingURL=index.mjs.map
