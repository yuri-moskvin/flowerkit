{"version":3,"file":"index.js","sources":["../../../src/evt/onSwipe/index.js"],"sourcesContent":["import ow from \"ow\";\r\nimport { getWindow } from \"ssr-window\";\r\nimport { isNode } from \"../../dom/isNode/index.js\";\r\nimport { isTouchDevice } from \"../../user/isTouchDevice/index.js\";\r\nimport { bubble } from \"../bubble/index.js\";\r\n\r\n/**\r\n * Adds custom `swipe` event on element.\r\n * Works on desktop and mobile browsers.\r\n * Supports speed, time and direction.\r\n * Generates custom `swipe` event on element or uses your own callback.\r\n * @param el{HTMLElement|Node|Element|Document} - DOM element\r\n * @param props{Object=} - swipe params\r\n * @param props.callback{Function=} - callback function after `swipe`\r\n * @param props.minDist{Number=} - min distance for swipe in `px`\r\n * @param props.maxDist{Number=} - max distance for swipe in `px`\r\n * @param props.minTime{Number=} - min duration of swipe in `ms`\r\n * @param props.maxTime{Number=} - max duration of swipe in `ms`\r\n * @param isAutoInit{Boolean=} - attaches event immediately\r\n * @return {{ handler: Object, addListener: Function, removeListener: Function }}\r\n * @example\r\n * // How to listen `swipe` event on element in JS?\r\n * // <div id=\"myBlock\"></div>\r\n * const myBlock = document.getElementById(\"myBlock\");\r\n * onSwipe(myBlock, {\r\n *   callback: ({ dist, dir, time }) => {\r\n *     console.log(dir, dist, time); // swipe direction, swipe distant, swipe time\r\n *     if(dir === \"right\") {\r\n *       // logic for right swipe\r\n *     }\r\n *   }\r\n * });\r\n * // Or with custom events:\r\n * onSwipe(myBlock);\r\n * myBlock.addEventListener(\"swipe\", (e) => console.log(e.detail));\r\n *\r\n * // Or manually add/remove listeners:\r\n * const { addListener, removeListener } = onSwipe(myBlock);\r\n * addListener(); // adds swipe listeners manually\r\n * removeListener(); // removes swipe listeners manually\r\n */\r\nconst onSwipe = (el, props = {}, isAutoInit = true) => {\r\n\r\n  ow(el, ow.object.validate(value => ({\r\n    validator: isNode(value),\r\n    message: () => `The object must be node`\r\n  })));\r\n\r\n  ow(props, ow.object.exactShape({\r\n    minDist: ow.optional.number.not.infinite,\r\n    maxDist: ow.optional.number.not.infinite,\r\n    maxTime: ow.optional.number.not.infinite,\r\n    minTime: ow.optional.number.not.infinite,\r\n    callback: ow.optional.function\r\n  }));\r\n\r\n  ow(isAutoInit, ow.optional.boolean);\r\n\r\n  const settings = {\r\n    minDist: 60,\r\n    maxDist: 120,\r\n    maxTime: 700,\r\n    minTime: 50,\r\n    callback: null,\r\n    ...props\r\n  };\r\n\r\n  if (settings.maxTime < settings.minTime) {\r\n    settings.maxTime = settings.minTime + 500;\r\n  }\r\n\r\n  if (settings.maxTime < 100 || settings.minTime < 50) {\r\n    settings.maxTime = 700;\r\n    settings.minTime = 50;\r\n  }\r\n\r\n  const eventsUnify = (e) => {\r\n    return e.changedTouches ? e.changedTouches[0] : e;\r\n  };\r\n\r\n  const isSupport = {\r\n    pointer: !!(\"PointerEvent\" in getWindow() || (\"msPointerEnabled\" in getWindow().navigator)),\r\n    touch: isTouchDevice()\r\n  };\r\n\r\n  const getSupportedEvents = () => {\r\n    switch (true) {\r\n      case isSupport.pointer:\r\n        return {\r\n          type: \"pointer\",\r\n          start: \"pointerdown\",\r\n          move: \"pointermove\",\r\n          end: \"pointerup\",\r\n          cancel: \"pointercancel\",\r\n          leave: \"pointerleave\"\r\n        };\r\n      case isSupport.touch:\r\n        return {\r\n          type: \"touch\",\r\n          start: \"touchstart\",\r\n          move: \"touchmove\",\r\n          end: \"touchend\",\r\n          cancel: \"touchcancel\",\r\n          leave: \"touchleave\"\r\n        };\r\n      default:\r\n        return {\r\n          type: \"mouse\",\r\n          start: \"mousedown\",\r\n          move: \"mousemove\",\r\n          end: \"mouseup\",\r\n          leave: \"mouseleave\"\r\n        };\r\n    }\r\n  };\r\n\r\n  const events = getSupportedEvents();\r\n\r\n  let dir,\r\n    swipeType,\r\n    dist,\r\n    isMouse = false,\r\n    isMouseDown = false,\r\n    startX = 0,\r\n    distX = 0,\r\n    startY = 0,\r\n    distY = 0,\r\n    startTime = 0;\r\n\r\n  /**\r\n   * Pointer first touch handler\r\n   * @param e{Event}\r\n   * @private\r\n   */\r\n  const checkStart = (e) => {\r\n    const event = eventsUnify(e);\r\n    if (isSupport.touch && typeof e.touches !== \"undefined\" && e.touches.length !== 1) {\r\n      return;\r\n    }\r\n    dir = \"none\";\r\n    swipeType = \"none\";\r\n    dist = 0;\r\n    startX = event.pageX || (event?.detail?._pageX ?? 0),\r\n    startY = event.pageY || (event?.detail?._pageY ?? 0),\r\n    startTime = new Date().getTime();\r\n    if (isMouse) {\r\n      isMouseDown = true;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Pointer movie touch handler\r\n   * @param e{Event}\r\n   * @private\r\n   */\r\n  const checkMove = (e) => {\r\n    if (isMouse && !isMouseDown) {\r\n      return;\r\n    }\r\n    const event = eventsUnify(e);\r\n    distX = (event.pageX || (event?.detail?._pageX ?? 0)) - startX;\r\n    distY = (event.pageY || (event?.detail?._pageY ?? 0)) - startY;\r\n    if (Math.abs(distX) > Math.abs(distY)) {\r\n      dir = (distX < 0) ? \"left\" : \"right\";\r\n    } else {\r\n      dir = (distY < 0) ? \"up\" : \"down\";\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Pointer end handler\r\n   * @param e{Event}\r\n   * @private\r\n   */\r\n  const checkEnd = (e) => {\r\n    if (isMouse && !isMouseDown) {\r\n      isMouseDown = false;\r\n      return;\r\n    }\r\n    const endTime = new Date().getTime();\r\n    const time = endTime - startTime;\r\n\r\n    if (time >= settings.minTime && time <= settings.maxTime) {\r\n      if (Math.abs(distX) >= settings.minDist && Math.abs(distY) <= settings.maxDist) {\r\n        swipeType = dir;\r\n      } else if (Math.abs(distY) >= settings.minDist && Math.abs(distX) <= settings.maxDist) {\r\n        swipeType = dir;\r\n      }\r\n    }\r\n\r\n    dist = (dir === \"left\" || dir === \"right\") ? Math.abs(distX) : Math.abs(distY);\r\n\r\n    if (e?.detail?._swipeType) {\r\n      swipeType = e.detail._swipeType;\r\n    }\r\n\r\n    if (swipeType !== \"none\" && dist >= settings.minDist) {\r\n      const detail = {\r\n        originEvent: e,\r\n        dir: swipeType,\r\n        dist,\r\n        time,\r\n        supportedEvents: events,\r\n      };\r\n      if (typeof settings.callback === \"function\") {\r\n        settings.callback(detail);\r\n      } else {\r\n        bubble(el, \"swipe\", detail, {\r\n          bubbles: true,\r\n          cancelable: true,\r\n        });\r\n      }\r\n    }\r\n  };\r\n\r\n  const handler = {\r\n    start: (e) => checkStart(e),\r\n    end: (e) => checkEnd(e),\r\n    move: (e) => checkMove(e)\r\n  };\r\n\r\n  if ((isSupport.pointer && !isSupport.touch) || events.type === \"mouse\") {\r\n    isMouse = true;\r\n  }\r\n\r\n  const listenerCtrl = (isBind = true) => {\r\n    const action = isBind ? \"addEventListener\" : \"removeEventListener\";\r\n    el[action](events.start, handler.start);\r\n    el[action](events.move, handler.move);\r\n    el[action](events.end, handler.end);\r\n    if (isSupport.pointer && isSupport.touch) {\r\n      el[action](\"lostpointercapture\", handler.end);\r\n    }\r\n  };\r\n\r\n  const addListener = () => {\r\n    listenerCtrl(true);\r\n  };\r\n\r\n  const removeListener = () => {\r\n    listenerCtrl(false);\r\n  };\r\n\r\n  if (isAutoInit) {\r\n    addListener();\r\n  }\r\n\r\n  return {\r\n    handler,\r\n    addListener,\r\n    removeListener\r\n  };\r\n};\r\n\r\nexport {\r\n  onSwipe\r\n};\r\n\r\n"],"names":["onSwipe","el","props","isAutoInit","ow","object","validate","value","validator","isNode","message","exactShape","minDist","optional","number","not","infinite","maxDist","maxTime","minTime","callback","function","boolean","settings","eventsUnify","e","changedTouches","isSupport","pointer","getWindow","navigator","touch","isTouchDevice","getSupportedEvents","type","start","move","end","cancel","leave","events","dir","swipeType","dist","isMouse","isMouseDown","startX","distX","startY","distY","startTime","checkStart","event","touches","length","pageX","detail","_pageX","pageY","_pageY","Date","getTime","checkMove","Math","abs","checkEnd","endTime","time","_swipeType","originEvent","supportedEvents","bubble","bubbles","cancelable","handler","listenerCtrl","isBind","action","addListener","removeListener"],"mappings":"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"}